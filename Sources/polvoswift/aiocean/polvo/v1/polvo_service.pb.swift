// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: aiocean/polvo/v1/polvo_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Aiocean_Polvo_V1_GetManifestUrlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_GetManifestUrlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var manifestURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_DeletePackageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_DeletePackageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_ListPackagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_ListPackagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packages: [Aiocean_Polvo_V1_Package] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_GetPackageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_GetPackageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var package: Aiocean_Polvo_V1_Package {
    get {return _package ?? Aiocean_Polvo_V1_Package()}
    set {_package = newValue}
  }
  /// Returns true if `package` has been explicitly set.
  var hasPackage: Bool {return self._package != nil}
  /// Clears the value of `package`. Subsequent reads from it will return its default value.
  mutating func clearPackage() {self._package = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _package: Aiocean_Polvo_V1_Package? = nil
}

struct Aiocean_Polvo_V1_CreatePackageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var package: Aiocean_Polvo_V1_Package {
    get {return _package ?? Aiocean_Polvo_V1_Package()}
    set {_package = newValue}
  }
  /// Returns true if `package` has been explicitly set.
  var hasPackage: Bool {return self._package != nil}
  /// Clears the value of `package`. Subsequent reads from it will return its default value.
  mutating func clearPackage() {self._package = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _package: Aiocean_Polvo_V1_Package? = nil
}

struct Aiocean_Polvo_V1_CreatePackageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var package: Aiocean_Polvo_V1_Package {
    get {return _package ?? Aiocean_Polvo_V1_Package()}
    set {_package = newValue}
  }
  /// Returns true if `package` has been explicitly set.
  var hasPackage: Bool {return self._package != nil}
  /// Clears the value of `package`. Subsequent reads from it will return its default value.
  mutating func clearPackage() {self._package = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _package: Aiocean_Polvo_V1_Package? = nil
}

struct Aiocean_Polvo_V1_ListVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_ListVersionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var versions: [Aiocean_Polvo_V1_Version] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_GetVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_GetVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Aiocean_Polvo_V1_Version {
    get {return _version ?? Aiocean_Polvo_V1_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Aiocean_Polvo_V1_Version? = nil
}

struct Aiocean_Polvo_V1_CreateVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packageOrn: String = String()

  var version: Aiocean_Polvo_V1_Version {
    get {return _version ?? Aiocean_Polvo_V1_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Aiocean_Polvo_V1_Version? = nil
}

struct Aiocean_Polvo_V1_CreateVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Aiocean_Polvo_V1_Version {
    get {return _version ?? Aiocean_Polvo_V1_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Aiocean_Polvo_V1_Version? = nil
}

struct Aiocean_Polvo_V1_UpdatePackageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var package: Aiocean_Polvo_V1_Package {
    get {return _package ?? Aiocean_Polvo_V1_Package()}
    set {_package = newValue}
  }
  /// Returns true if `package` has been explicitly set.
  var hasPackage: Bool {return self._package != nil}
  /// Clears the value of `package`. Subsequent reads from it will return its default value.
  mutating func clearPackage() {self._package = nil}

  var fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _fieldMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_fieldMask = newValue}
  }
  /// Returns true if `fieldMask` has been explicitly set.
  var hasFieldMask: Bool {return self._fieldMask != nil}
  /// Clears the value of `fieldMask`. Subsequent reads from it will return its default value.
  mutating func clearFieldMask() {self._fieldMask = nil}

  var orn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _package: Aiocean_Polvo_V1_Package? = nil
  fileprivate var _fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

struct Aiocean_Polvo_V1_UpdatePackageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var package: Aiocean_Polvo_V1_Package {
    get {return _package ?? Aiocean_Polvo_V1_Package()}
    set {_package = newValue}
  }
  /// Returns true if `package` has been explicitly set.
  var hasPackage: Bool {return self._package != nil}
  /// Clears the value of `package`. Subsequent reads from it will return its default value.
  mutating func clearPackage() {self._package = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _package: Aiocean_Polvo_V1_Package? = nil
}

struct Aiocean_Polvo_V1_UpdateVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orn: String = String()

  var version: Aiocean_Polvo_V1_Version {
    get {return _version ?? Aiocean_Polvo_V1_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _fieldMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_fieldMask = newValue}
  }
  /// Returns true if `fieldMask` has been explicitly set.
  var hasFieldMask: Bool {return self._fieldMask != nil}
  /// Clears the value of `fieldMask`. Subsequent reads from it will return its default value.
  mutating func clearFieldMask() {self._fieldMask = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Aiocean_Polvo_V1_Version? = nil
  fileprivate var _fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

struct Aiocean_Polvo_V1_DeleteVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_DeleteVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Aiocean_Polvo_V1_UpdateVersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Aiocean_Polvo_V1_Version {
    get {return _version ?? Aiocean_Polvo_V1_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Aiocean_Polvo_V1_Version? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "aiocean.polvo.v1"

extension Aiocean_Polvo_V1_GetManifestUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetManifestUrlRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_GetManifestUrlRequest, rhs: Aiocean_Polvo_V1_GetManifestUrlRequest) -> Bool {
    if lhs.orn != rhs.orn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_GetManifestUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetManifestUrlResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "manifest_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.manifestURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.manifestURL.isEmpty {
      try visitor.visitSingularStringField(value: self.manifestURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_GetManifestUrlResponse, rhs: Aiocean_Polvo_V1_GetManifestUrlResponse) -> Bool {
    if lhs.manifestURL != rhs.manifestURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_DeletePackageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeletePackageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_DeletePackageRequest, rhs: Aiocean_Polvo_V1_DeletePackageRequest) -> Bool {
    if lhs.orn != rhs.orn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_DeletePackageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeletePackageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_DeletePackageResponse, rhs: Aiocean_Polvo_V1_DeletePackageResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_ListPackagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPackagesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_ListPackagesRequest, rhs: Aiocean_Polvo_V1_ListPackagesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_ListPackagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListPackagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.packages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_ListPackagesResponse, rhs: Aiocean_Polvo_V1_ListPackagesResponse) -> Bool {
    if lhs.packages != rhs.packages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_GetPackageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPackageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_GetPackageRequest, rhs: Aiocean_Polvo_V1_GetPackageRequest) -> Bool {
    if lhs.orn != rhs.orn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_GetPackageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPackageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._package) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._package {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_GetPackageResponse, rhs: Aiocean_Polvo_V1_GetPackageResponse) -> Bool {
    if lhs._package != rhs._package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_CreatePackageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreatePackageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "package"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._package) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._package {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_CreatePackageRequest, rhs: Aiocean_Polvo_V1_CreatePackageRequest) -> Bool {
    if lhs._package != rhs._package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_CreatePackageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreatePackageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._package) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._package {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_CreatePackageResponse, rhs: Aiocean_Polvo_V1_CreatePackageResponse) -> Bool {
    if lhs._package != rhs._package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_ListVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListVersionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_ListVersionsRequest, rhs: Aiocean_Polvo_V1_ListVersionsRequest) -> Bool {
    if lhs.orn != rhs.orn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_ListVersionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListVersionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.versions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.versions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_ListVersionsResponse, rhs: Aiocean_Polvo_V1_ListVersionsResponse) -> Bool {
    if lhs.versions != rhs.versions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_GetVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetVersionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_GetVersionRequest, rhs: Aiocean_Polvo_V1_GetVersionRequest) -> Bool {
    if lhs.orn != rhs.orn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_GetVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetVersionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_GetVersionResponse, rhs: Aiocean_Polvo_V1_GetVersionResponse) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_CreateVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateVersionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_orn"),
    2: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.packageOrn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packageOrn.isEmpty {
      try visitor.visitSingularStringField(value: self.packageOrn, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_CreateVersionRequest, rhs: Aiocean_Polvo_V1_CreateVersionRequest) -> Bool {
    if lhs.packageOrn != rhs.packageOrn {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_CreateVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateVersionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_CreateVersionResponse, rhs: Aiocean_Polvo_V1_CreateVersionResponse) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_UpdatePackageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePackageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
    2: .standard(proto: "field_mask"),
    3: .same(proto: "orn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._package) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fieldMask) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._package {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._fieldMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_UpdatePackageRequest, rhs: Aiocean_Polvo_V1_UpdatePackageRequest) -> Bool {
    if lhs._package != rhs._package {return false}
    if lhs._fieldMask != rhs._fieldMask {return false}
    if lhs.orn != rhs.orn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_UpdatePackageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePackageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "package"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._package) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._package {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_UpdatePackageResponse, rhs: Aiocean_Polvo_V1_UpdatePackageResponse) -> Bool {
    if lhs._package != rhs._package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_UpdateVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateVersionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orn"),
    2: .same(proto: "version"),
    3: .standard(proto: "field_mask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fieldMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 1)
    }
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._fieldMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_UpdateVersionRequest, rhs: Aiocean_Polvo_V1_UpdateVersionRequest) -> Bool {
    if lhs.orn != rhs.orn {return false}
    if lhs._version != rhs._version {return false}
    if lhs._fieldMask != rhs._fieldMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_DeleteVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteVersionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orn.isEmpty {
      try visitor.visitSingularStringField(value: self.orn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_DeleteVersionRequest, rhs: Aiocean_Polvo_V1_DeleteVersionRequest) -> Bool {
    if lhs.orn != rhs.orn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_DeleteVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteVersionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_DeleteVersionResponse, rhs: Aiocean_Polvo_V1_DeleteVersionResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Aiocean_Polvo_V1_UpdateVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateVersionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Aiocean_Polvo_V1_UpdateVersionResponse, rhs: Aiocean_Polvo_V1_UpdateVersionResponse) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
